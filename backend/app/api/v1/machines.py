from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.orm import Session
from sqlalchemy import or_, func
from typing import Optional
import re

from app.database import get_db
from app.models.user import User
from app.models.machine import Machine
from app.models.payment import Payment
from app.dependencies import get_current_user
from app.core.security import get_password_hash
from app.schemas.machine import MachineCreate, MachineUpdate, MachineResponse, MachineStatusUpdate
from app.schemas.common import SuccessResponse, MessageResponse
from app.utils.alert_service import create_alert_if_not_exists, resolve_machine_alerts
from app.models.alert import AlertSeverity

router = APIRouter()


@router.post("/", response_model=SuccessResponse[MachineResponse], status_code=status.HTTP_201_CREATED)
async def create_machine(
    machine_data: MachineCreate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Create a new machine with auto-generated username.
    
    The username is generated by combining the prefix with an auto-incremented number.
    For example, if prefix is "admin", usernames will be: admin001, admin002, etc.
    
    Args:
        machine_data: Machine creation data
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Created machine details
    """
    # Generate username with auto-increment
    prefix = machine_data.username_prefix
    
    # Find the highest number with this prefix
    existing_machines = db.query(Machine).filter(
        Machine.username.like(f"{prefix}%")
    ).order_by(Machine.username.desc()).all()
    
    # Extract numbers and find the max
    max_number = 0
    for machine in existing_machines:
        # Extract number from username (e.g., "admin001" -> 1)
        match = re.search(r'(\d+)$', machine.username)
        if match:
            number = int(match.group(1))
            max_number = max(max_number, number)
    
    # Generate new username
    new_number = max_number + 1
    username = f"{prefix}{new_number:03d}"  # e.g., admin001
    
    # Hash password
    hashed_password = get_password_hash(machine_data.password)
    
    # Create machine
    machine = Machine(
        user_id=current_user.id,  # Auto-assign to current admin
        name=machine_data.name,
        location=machine_data.location,
        username=username,
        hashed_password=hashed_password,
        status="offline"
    )
    
    try:
        db.add(machine)
        db.commit()
        db.refresh(machine)
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to create machine: {str(e)}"
        )
    
    return {
        "success": True,
        "data": MachineResponse(
            id=str(machine.id),
            user_id=str(machine.user_id),
            name=machine.name,
            location=machine.location,
            username=machine.username,
            status=machine.status,
            last_sync=machine.last_sync,
            online_collection=float(machine.online_collection),
            offline_collection=float(machine.offline_collection),
            created_at=machine.created_at,
            updated_at=machine.updated_at
        )
    }


@router.get("/", response_model=SuccessResponse[dict])
async def get_machines(
    page: int = Query(1, ge=1, description="Page number"),
    limit: int = Query(20, ge=1, le=100, description="Items per page"),
    status: Optional[str] = Query(None, pattern="^(online|offline|maintenance)$", description="Filter by status"),
    search: Optional[str] = Query(None, description="Search by name, location, or username"),
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get list of all machines with pagination and filtering.
    
    Query Parameters:
        page: Page number (default: 1)
        limit: Items per page (default: 20, max: 100)
        status: Filter by status (online | offline | maintenance)
        search: Search by name, location, or username
        
    Returns:
        Paginated list of machines
    """
    query = db.query(Machine).filter(Machine.user_id == current_user.id)  # Filter by admin
    
    # Apply filters
    if status:
        query = query.filter(Machine.status == status)
    
    if search:
        search_pattern = f"%{search}%"
        query = query.filter(
            or_(
                Machine.name.ilike(search_pattern),
                Machine.location.ilike(search_pattern),
                Machine.username.ilike(search_pattern)
            )
        )
    
    # Get total count
    total = query.count()
    
    # Apply pagination
    machines = query.order_by(Machine.created_at.desc()).offset((page - 1) * limit).limit(limit).all()
    
    # Calculate stats efficiently
    if machines:
        machine_ids = [m.id for m in machines]
        
        # Calculate online collections per machine
        online_stats = db.query(Payment.machine_id, func.sum(Payment.amount))\
            .filter(
                Payment.machine_id.in_(machine_ids),
                Payment.status == 'success',
                Payment.method.in_(['UPI', 'Card'])
            )\
            .group_by(Payment.machine_id).all()
        online_map = {str(mid): float(amount or 0) for mid, amount in online_stats}

        # Calculate offline collections per machine
        offline_stats = db.query(Payment.machine_id, func.sum(Payment.amount))\
            .filter(
                Payment.machine_id.in_(machine_ids),
                Payment.status == 'success',
                Payment.method.in_(['Cash'])
            )\
            .group_by(Payment.machine_id).all()
        offline_map = {str(mid): float(amount or 0) for mid, amount in offline_stats}
    else:
        online_map = {}
        offline_map = {}
    
    # Convert to response format
    machines_data = [
        MachineResponse(
            id=str(m.id),
            user_id=str(m.user_id),
            name=m.name,
            location=m.location,
            username=m.username,
            status=m.status,
            last_sync=m.last_sync,
            online_collection=online_map.get(str(m.id), 0.0),
            offline_collection=offline_map.get(str(m.id), 0.0),
            created_at=m.created_at,
            updated_at=m.updated_at
        )
        for m in machines
    ]
    
    return {
        "success": True,
        "data": {
            "machines": machines_data,
            "pagination": {
                "current_page": page,
                "total_pages": (total + limit - 1) // limit,
                "total_items": total,
                "items_per_page": limit
            }
        }
    }


@router.get("/{machine_id}", response_model=SuccessResponse[MachineResponse])
async def get_machine(
    machine_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Get detailed information about a specific machine.
    
    Args:
        machine_id: Machine UUID
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Machine details
    """
    machine = db.query(Machine).filter(Machine.id == machine_id).first()
    
    if not machine:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Machine not found"
        )

    # Calculate collections dynamically
    # Online: UPI + Card (success)
    online_total = db.query(func.sum(Payment.amount))\
        .filter(
            Payment.machine_id == machine_id,
            Payment.status == 'success',
            Payment.method.in_(['UPI', 'Card'])
        ).scalar() or 0.0

    # Offline: Cash (success)
    offline_total = db.query(func.sum(Payment.amount))\
        .filter(
            Payment.machine_id == machine_id,
            Payment.status == 'success',
            Payment.method.in_(['Cash'])
        ).scalar() or 0.0
    
    return {
        "success": True,
        "data": MachineResponse(
            id=str(machine.id),
            user_id=str(machine.user_id),
            name=machine.name,
            location=machine.location,
            username=machine.username,
            status=machine.status,
            last_sync=machine.last_sync,
            online_collection=float(online_total),
            offline_collection=float(offline_total),
            created_at=machine.created_at,
            updated_at=machine.updated_at
        )
    }


@router.put("/{machine_id}", response_model=SuccessResponse[MachineResponse])
async def update_machine(
    machine_id: str,
    machine_data: MachineUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Update machine details.
    
    All fields are optional. Only provided fields will be updated.
    If password is provided, it will be hashed before storing.
    
    Args:
        machine_id: Machine UUID
        machine_data: Updated machine data
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Updated machine details
    """
    machine = db.query(Machine).filter(Machine.id == machine_id).first()
    
    if not machine:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Machine not found"
        )
    
    # Update fields if provided
    if machine_data.name is not None:
        machine.name = machine_data.name
    
    if machine_data.location is not None:
        machine.location = machine_data.location
    
    if machine_data.username is not None:
        # Check if username is already taken by another machine
        existing = db.query(Machine).filter(
            Machine.username == machine_data.username,
            Machine.id != machine_id
        ).first()
        
        if existing:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username already exists"
            )
        
        machine.username = machine_data.username
    
    if machine_data.password is not None:
        machine.hashed_password = get_password_hash(machine_data.password)
    
    new_status = machine_data.status
    if new_status is not None:
        machine.status = new_status

    try:
        db.commit()
        db.refresh(machine)
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to update machine: {str(e)}"
        )

    # Handle alerts based on new status
    if new_status == 'offline':
        create_alert_if_not_exists(
            db, str(machine.id), AlertSeverity.CRITICAL,
            "Machine Offline", "Machine was manually set to offline"
        )
    elif new_status == 'maintenance':
        create_alert_if_not_exists(
            db, str(machine.id), AlertSeverity.WARNING,
            "Maintenance Mode", "Machine is in maintenance mode"
        )
    elif new_status == 'online':
        resolve_machine_alerts(db, str(machine.id))

    return {
        "success": True,
        "data": MachineResponse(
            id=str(machine.id),
            user_id=str(machine.user_id),
            name=machine.name,
            location=machine.location,
            username=machine.username,
            status=machine.status,
            last_sync=machine.last_sync,
            online_collection=float(machine.online_collection),
            offline_collection=float(machine.offline_collection),
            created_at=machine.created_at,
            updated_at=machine.updated_at
        )
    }


@router.patch("/{machine_id}/status", response_model=SuccessResponse[MachineResponse])
async def update_machine_status(
    machine_id: str,
    status_data: MachineStatusUpdate,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Update machine status, last_sync, and collection amounts.
    
    This endpoint is used by client apps to update their status
    and sync information without requiring all machine fields.
    
    Args:
        machine_id: Machine UUID
        status_data: Status update data
        db: Database session
        current_user: Current authenticated user (or machine)
        
    Returns:
        Updated machine details
    """
    machine = db.query(Machine).filter(
        Machine.id == machine_id,
        Machine.user_id == current_user.id  # Verify ownership
    ).first()
    
    if not machine:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Machine not found"
        )
    
    # Update fields if provided
    if status_data.status is not None:
        machine.status = status_data.status
    
    if status_data.last_sync is not None:
        machine.last_sync = status_data.last_sync
    
    if status_data.online_collection is not None:
        machine.online_collection = status_data.online_collection
    
    if status_data.offline_collection is not None:
        machine.offline_collection = status_data.offline_collection
    
    try:
        db.commit()
        db.refresh(machine)
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to update machine status: {str(e)}"
        )
    
    return {
        "success": True,
        "data": MachineResponse(
            id=str(machine.id),
            user_id=str(machine.user_id),
            name=machine.name,
            location=machine.location,
            username=machine.username,
            status=machine.status,
            last_sync=machine.last_sync,
            online_collection=float(machine.online_collection),
            offline_collection=float(machine.offline_collection),
            created_at=machine.created_at,
            updated_at=machine.updated_at
        )
    }


@router.delete("/{machine_id}", response_model=MessageResponse)
async def delete_machine(
    machine_id: str,
    db: Session = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Delete a machine.
    
    Args:
        machine_id: Machine UUID
        db: Database session
        current_user: Current authenticated user
        
    Returns:
        Success message
    """
    machine = db.query(Machine).filter(
        Machine.id == machine_id,
        Machine.user_id == current_user.id  # Verify ownership
    ).first()
    
    if not machine:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Machine not found"
        )
    
    try:
        db.delete(machine)
        db.commit()
    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Failed to delete machine: {str(e)}"
        )
    
    return {
        "success": True,
        "message": "Machine deleted successfully"
    }
